// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'location_metadata_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

LocationMetadataResponse _$LocationMetadataResponseFromJson(
    Map<String, dynamic> json) {
  return _LocationMetadataResponse.fromJson(json);
}

/// @nodoc
mixin _$LocationMetadataResponse {
  int get Version => throw _privateConstructorUsedError;
  String get Key => throw _privateConstructorUsedError;
  String get Type => throw _privateConstructorUsedError;
  int get Rank => throw _privateConstructorUsedError;
  String get EnglishName => throw _privateConstructorUsedError;
  String get PrimaryPostalCode => throw _privateConstructorUsedError;
  Map<String, dynamic> get Region => throw _privateConstructorUsedError;
  Map<String, dynamic> get Country => throw _privateConstructorUsedError;
  Map<String, dynamic> get AdministrativeArea =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> get TimeZone => throw _privateConstructorUsedError;
  Map<String, dynamic> get GeoPosition => throw _privateConstructorUsedError;
  String? get ParentCity => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LocationMetadataResponseCopyWith<LocationMetadataResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocationMetadataResponseCopyWith<$Res> {
  factory $LocationMetadataResponseCopyWith(LocationMetadataResponse value,
          $Res Function(LocationMetadataResponse) then) =
      _$LocationMetadataResponseCopyWithImpl<$Res, LocationMetadataResponse>;
  @useResult
  $Res call(
      {int Version,
      String Key,
      String Type,
      int Rank,
      String EnglishName,
      String PrimaryPostalCode,
      Map<String, dynamic> Region,
      Map<String, dynamic> Country,
      Map<String, dynamic> AdministrativeArea,
      Map<String, dynamic> TimeZone,
      Map<String, dynamic> GeoPosition,
      String? ParentCity});
}

/// @nodoc
class _$LocationMetadataResponseCopyWithImpl<$Res,
        $Val extends LocationMetadataResponse>
    implements $LocationMetadataResponseCopyWith<$Res> {
  _$LocationMetadataResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? Version = null,
    Object? Key = null,
    Object? Type = null,
    Object? Rank = null,
    Object? EnglishName = null,
    Object? PrimaryPostalCode = null,
    Object? Region = null,
    Object? Country = null,
    Object? AdministrativeArea = null,
    Object? TimeZone = null,
    Object? GeoPosition = null,
    Object? ParentCity = freezed,
  }) {
    return _then(_value.copyWith(
      Version: null == Version
          ? _value.Version
          : Version // ignore: cast_nullable_to_non_nullable
              as int,
      Key: null == Key
          ? _value.Key
          : Key // ignore: cast_nullable_to_non_nullable
              as String,
      Type: null == Type
          ? _value.Type
          : Type // ignore: cast_nullable_to_non_nullable
              as String,
      Rank: null == Rank
          ? _value.Rank
          : Rank // ignore: cast_nullable_to_non_nullable
              as int,
      EnglishName: null == EnglishName
          ? _value.EnglishName
          : EnglishName // ignore: cast_nullable_to_non_nullable
              as String,
      PrimaryPostalCode: null == PrimaryPostalCode
          ? _value.PrimaryPostalCode
          : PrimaryPostalCode // ignore: cast_nullable_to_non_nullable
              as String,
      Region: null == Region
          ? _value.Region
          : Region // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      Country: null == Country
          ? _value.Country
          : Country // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      AdministrativeArea: null == AdministrativeArea
          ? _value.AdministrativeArea
          : AdministrativeArea // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      TimeZone: null == TimeZone
          ? _value.TimeZone
          : TimeZone // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      GeoPosition: null == GeoPosition
          ? _value.GeoPosition
          : GeoPosition // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      ParentCity: freezed == ParentCity
          ? _value.ParentCity
          : ParentCity // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LocationMetadataResponseImplCopyWith<$Res>
    implements $LocationMetadataResponseCopyWith<$Res> {
  factory _$$LocationMetadataResponseImplCopyWith(
          _$LocationMetadataResponseImpl value,
          $Res Function(_$LocationMetadataResponseImpl) then) =
      __$$LocationMetadataResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int Version,
      String Key,
      String Type,
      int Rank,
      String EnglishName,
      String PrimaryPostalCode,
      Map<String, dynamic> Region,
      Map<String, dynamic> Country,
      Map<String, dynamic> AdministrativeArea,
      Map<String, dynamic> TimeZone,
      Map<String, dynamic> GeoPosition,
      String? ParentCity});
}

/// @nodoc
class __$$LocationMetadataResponseImplCopyWithImpl<$Res>
    extends _$LocationMetadataResponseCopyWithImpl<$Res,
        _$LocationMetadataResponseImpl>
    implements _$$LocationMetadataResponseImplCopyWith<$Res> {
  __$$LocationMetadataResponseImplCopyWithImpl(
      _$LocationMetadataResponseImpl _value,
      $Res Function(_$LocationMetadataResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? Version = null,
    Object? Key = null,
    Object? Type = null,
    Object? Rank = null,
    Object? EnglishName = null,
    Object? PrimaryPostalCode = null,
    Object? Region = null,
    Object? Country = null,
    Object? AdministrativeArea = null,
    Object? TimeZone = null,
    Object? GeoPosition = null,
    Object? ParentCity = freezed,
  }) {
    return _then(_$LocationMetadataResponseImpl(
      Version: null == Version
          ? _value.Version
          : Version // ignore: cast_nullable_to_non_nullable
              as int,
      Key: null == Key
          ? _value.Key
          : Key // ignore: cast_nullable_to_non_nullable
              as String,
      Type: null == Type
          ? _value.Type
          : Type // ignore: cast_nullable_to_non_nullable
              as String,
      Rank: null == Rank
          ? _value.Rank
          : Rank // ignore: cast_nullable_to_non_nullable
              as int,
      EnglishName: null == EnglishName
          ? _value.EnglishName
          : EnglishName // ignore: cast_nullable_to_non_nullable
              as String,
      PrimaryPostalCode: null == PrimaryPostalCode
          ? _value.PrimaryPostalCode
          : PrimaryPostalCode // ignore: cast_nullable_to_non_nullable
              as String,
      Region: null == Region
          ? _value._Region
          : Region // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      Country: null == Country
          ? _value._Country
          : Country // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      AdministrativeArea: null == AdministrativeArea
          ? _value._AdministrativeArea
          : AdministrativeArea // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      TimeZone: null == TimeZone
          ? _value._TimeZone
          : TimeZone // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      GeoPosition: null == GeoPosition
          ? _value._GeoPosition
          : GeoPosition // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      ParentCity: freezed == ParentCity
          ? _value.ParentCity
          : ParentCity // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LocationMetadataResponseImpl extends _LocationMetadataResponse {
  const _$LocationMetadataResponseImpl(
      {required this.Version,
      required this.Key,
      required this.Type,
      required this.Rank,
      required this.EnglishName,
      required this.PrimaryPostalCode,
      required final Map<String, dynamic> Region,
      required final Map<String, dynamic> Country,
      required final Map<String, dynamic> AdministrativeArea,
      required final Map<String, dynamic> TimeZone,
      required final Map<String, dynamic> GeoPosition,
      this.ParentCity})
      : _Region = Region,
        _Country = Country,
        _AdministrativeArea = AdministrativeArea,
        _TimeZone = TimeZone,
        _GeoPosition = GeoPosition,
        super._();

  factory _$LocationMetadataResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$LocationMetadataResponseImplFromJson(json);

  @override
  final int Version;
  @override
  final String Key;
  @override
  final String Type;
  @override
  final int Rank;
  @override
  final String EnglishName;
  @override
  final String PrimaryPostalCode;
  final Map<String, dynamic> _Region;
  @override
  Map<String, dynamic> get Region {
    if (_Region is EqualUnmodifiableMapView) return _Region;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_Region);
  }

  final Map<String, dynamic> _Country;
  @override
  Map<String, dynamic> get Country {
    if (_Country is EqualUnmodifiableMapView) return _Country;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_Country);
  }

  final Map<String, dynamic> _AdministrativeArea;
  @override
  Map<String, dynamic> get AdministrativeArea {
    if (_AdministrativeArea is EqualUnmodifiableMapView)
      return _AdministrativeArea;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_AdministrativeArea);
  }

  final Map<String, dynamic> _TimeZone;
  @override
  Map<String, dynamic> get TimeZone {
    if (_TimeZone is EqualUnmodifiableMapView) return _TimeZone;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_TimeZone);
  }

  final Map<String, dynamic> _GeoPosition;
  @override
  Map<String, dynamic> get GeoPosition {
    if (_GeoPosition is EqualUnmodifiableMapView) return _GeoPosition;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_GeoPosition);
  }

  @override
  final String? ParentCity;

  @override
  String toString() {
    return 'LocationMetadataResponse(Version: $Version, Key: $Key, Type: $Type, Rank: $Rank, EnglishName: $EnglishName, PrimaryPostalCode: $PrimaryPostalCode, Region: $Region, Country: $Country, AdministrativeArea: $AdministrativeArea, TimeZone: $TimeZone, GeoPosition: $GeoPosition, ParentCity: $ParentCity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LocationMetadataResponseImpl &&
            (identical(other.Version, Version) || other.Version == Version) &&
            (identical(other.Key, Key) || other.Key == Key) &&
            (identical(other.Type, Type) || other.Type == Type) &&
            (identical(other.Rank, Rank) || other.Rank == Rank) &&
            (identical(other.EnglishName, EnglishName) ||
                other.EnglishName == EnglishName) &&
            (identical(other.PrimaryPostalCode, PrimaryPostalCode) ||
                other.PrimaryPostalCode == PrimaryPostalCode) &&
            const DeepCollectionEquality().equals(other._Region, _Region) &&
            const DeepCollectionEquality().equals(other._Country, _Country) &&
            const DeepCollectionEquality()
                .equals(other._AdministrativeArea, _AdministrativeArea) &&
            const DeepCollectionEquality().equals(other._TimeZone, _TimeZone) &&
            const DeepCollectionEquality()
                .equals(other._GeoPosition, _GeoPosition) &&
            (identical(other.ParentCity, ParentCity) ||
                other.ParentCity == ParentCity));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      Version,
      Key,
      Type,
      Rank,
      EnglishName,
      PrimaryPostalCode,
      const DeepCollectionEquality().hash(_Region),
      const DeepCollectionEquality().hash(_Country),
      const DeepCollectionEquality().hash(_AdministrativeArea),
      const DeepCollectionEquality().hash(_TimeZone),
      const DeepCollectionEquality().hash(_GeoPosition),
      ParentCity);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LocationMetadataResponseImplCopyWith<_$LocationMetadataResponseImpl>
      get copyWith => __$$LocationMetadataResponseImplCopyWithImpl<
          _$LocationMetadataResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LocationMetadataResponseImplToJson(
      this,
    );
  }
}

abstract class _LocationMetadataResponse extends LocationMetadataResponse {
  const factory _LocationMetadataResponse(
      {required final int Version,
      required final String Key,
      required final String Type,
      required final int Rank,
      required final String EnglishName,
      required final String PrimaryPostalCode,
      required final Map<String, dynamic> Region,
      required final Map<String, dynamic> Country,
      required final Map<String, dynamic> AdministrativeArea,
      required final Map<String, dynamic> TimeZone,
      required final Map<String, dynamic> GeoPosition,
      final String? ParentCity}) = _$LocationMetadataResponseImpl;
  const _LocationMetadataResponse._() : super._();

  factory _LocationMetadataResponse.fromJson(Map<String, dynamic> json) =
      _$LocationMetadataResponseImpl.fromJson;

  @override
  int get Version;
  @override
  String get Key;
  @override
  String get Type;
  @override
  int get Rank;
  @override
  String get EnglishName;
  @override
  String get PrimaryPostalCode;
  @override
  Map<String, dynamic> get Region;
  @override
  Map<String, dynamic> get Country;
  @override
  Map<String, dynamic> get AdministrativeArea;
  @override
  Map<String, dynamic> get TimeZone;
  @override
  Map<String, dynamic> get GeoPosition;
  @override
  String? get ParentCity;
  @override
  @JsonKey(ignore: true)
  _$$LocationMetadataResponseImplCopyWith<_$LocationMetadataResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}
